# Type Inference

Модуль автовывода типов предназчен для ситуаций, когда заданный код из языка,
например, с динамической типизацией, нужно корректно представить в языке со
статической типизацией и явным указанием типов, по возможности не применяя везде самый общий тип.

## Класс `HindleyMilner`

### Предназначение

`HindleyMilner` реализует механизм вывода типов для выражений и
конструкций на основе упрощённого варианта одноимённой системы Хиндли-Милнера.
Класс предоставляет набор статических функций, обходящих AST‑дерево и
вычисляющих типы узлов с учётом областей видимости, поведенческих
шаблонов операций и распространения информации о типах.

### Основные группы методов

-   **inference(Literal/Expression/Statement/Declaration, scope)** -
    центральный механизм вывода типов, выполняющий рекурсивный глубокий
    обход.
-   **chooseGeneralType** - определение наиболее общего типа двух или
    нескольких типов.
-   **backwardVariableTypeSet** - «обратное» распространение типов:
    если выражение требует определённый тип, он назначается
    идентификаторам, участвующим в выражении.
-   **inferenceOperandsTypeByExpressionType** - вывод типа операндов
    на основе типа выражения‑контейнера.
-   **Обработка конкретных видов узлов**: бинарные, унарные, тернарные,
    диапазоны, литералы, идентификаторы, объявления переменных и т.д.

### Ключевые особенности и детали реализации

1.  **Глубокий обход AST**\
    Метод `inference(expression, scope)` вызывает специализированные
    обработчики:

    -   литералы -> точный известный тип (IntType, FloatType и т.п.);
    -   идентификаторы -> берутся из текущей области видимости
        (`TypeScope`);
    -   бинарные/унарные/тернарные выражения -> рекурсивный вывод типов
        дочерних узлов.

    Такой обход позволяет заранее заполнить `TypeScope` всеми известными
    типами, встретившимися в подвыражениях.

2.  **Ограничения относительно методов**\

    -   Cистема не выводит типы методов по сигнатурам, а лишь ищет их
        типа возврата в `TypeScope`;
    -   Нет поддержки полиморфных методов или перегрузки -- метод
        считается имеющим один фиксированный тип, записанный в область
        видимости.

3.  **Обратный проход («backward propagation»)**\
    Когда тип выражения известен, но тип его составляющих неизвестен,
    вызывается:

    ``` java
    backwardVariableTypeSet(expr, scope, inferredType)
    ```

    Это позволяет корректировать типы переменных, например:

    -   если операция `/` всегда возвращает `FloatType`, то её операнды
        получают тип `FloatType`;
    -   при сравнении двух неизвестных значений типы приводятся к
        float'ам (`BinaryComparison`).

4.  **Слияние типов (`chooseGeneralType`)**\
    Поддерживает:

    -   Int + Float -> Float
    -   String + что угодно -> String
    -   Boolean + Boolean -> Boolean
    -   При несовместимости -> UnknownType

    Эта стратегия совпадает со стратегией вывода типов в `Java` - кастомизация задания кастомной стратегии
    пока не поддерживается.

    Используется при:

    -   определении типа бинарных выражений,
    -   типизации коллекций (списки, множества, словари),
    -   определении типа объявления переменных (`VariableDeclaration`).

5.  **Типизация коллекций**\
    Для `ListLiteral`, `SetLiteral`, `DictionaryLiteral`,
    `UnmodifiableListLiteral`, `ArrayLiteral`:

    -   сначала проверяются явные type hints;
    -   если hints нет -- вывод типа на основе элементов
        (`inference(list)` -> список типов  `chooseGeneralType`).

6.  **Обработка бинарных выражений** Алгоритм:

    1.  Вывести тип левого и правого выражения.
    2.  Если оба неизвестны, установить типы по контексту операции
        (например, `FloatType` для деления или сравнения).
    3.  Если известен один --- скопировать его на другой через
        `backwardVariableTypeSet`.
    4.  Вывести общий тип операции.
    5.  Вернуть общий тип как тип выражения.

7.  **Унарные операции**\
    Обработка пред- и пост-инкремента/декремента, `NotOp`,
    `UnaryMinusOp` и др.\
    Если операнд неизвестен -> ему назначается тип `FloatType`.

8.  **Вывод типов в операторах и блоках**\
    Класс содержит версии `inference()` для:

    -   `AssignmentStatement`
    -   `CompoundStatement`
    -   `IfStatement`, `SwitchStatement`
    -   `VariableDeclaration`, `VariableDeclarator`
    -   `DeclarationArgument`
    -   и универсальный обход списка `List<Node>`

## Класс `TypeScope`

### Предназначение

Обеспечивает управление областями видимости типов переменных и методов.
Представляет стек областей, автоматически поддерживая вложенные блоки.

### Основные методы

-   **enter() / leave()** - вход и выход из блока.
-   **addVariable(name, type)** - объявление новой переменной.
-   **addMethod(name, returnType)** - регистрация метода.
-   **getVariableType(name)** - поиск типа вверх по цепочке областей.
-   **changeVariableType(name, type)** - изменение/создание
    переменной.
-   **getMethodReturnType(name)** - поиск типа метода.

### Использование

`TypeScope` передаётся во все методы инференса и обновляется по мере
анализа конструкции. Таким образом, контекст типов всегда соответствует
текущей точке разбора AST.

## Класс `TypedEntities`

### Предназначение

Хранит содержимое одной конкретной области видимости: переменные и
методы. Связан с родительской областью, что обеспечивает цепочку поиска
идентификатора.

### Основные методы

-   **addVariable(name, type)** - добавить или переопределить
    переменную.
-   **addMethod(name, type)** - записать возвращаемый тип метода.
-   **getVariableType(name)** - поиск переменной в текущей и
    родительских областях.
-   **changeVariableType(name, type)** - обновление или создание
    переменной.
-   **getMethodReturnType(name)** - аналогично, но для метода.

### Использование

`HindleyMilner` не работает напрямую с `TypedEntities`; он всегда
взаимодействует с ними через `TypeScope`.\
`TypedEntities` - это внутренний слой, отвечающий исключительно за
хранение данных без логики вывода.

## Общая схема работы механизма вывода типов

1.  **Инициируется корневой `TypeScope`.**
2.  **Запускается вывод типа выражения или инструкции.**
3.  **Выполняется рекурсивный проход вниз по узлам AST**:
    -   вычисляются типы подвыражений,\
    -   обновляется `TypeScope`.
4.  **После вычисления локальных типов выполняется обратный проход
    (частичный)** через:
    -   `backwardVariableTypeSet`,
    -   корректировки в бинарных/унарных операциях.
5.  **Типы нестатических коллекций выводятся через объединение типов их
    элементов.**
6.  **Типы деклараций переменных устанавливаются как общий тип всех его
    `Declarator`‑ов.**
7.  **Если тип определить невозможно -> используется `UnknownType`.**

Такой подход даёт:
- локальный вывод типов;
- корректировку типов по контексту операций;
- постепенное уточнение типов идентификаторов на основе использования;
- поддержку сложных структур (сравнения, диапазоны, тернарные выражения, коллекции).
